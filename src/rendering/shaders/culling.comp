#version 460

#include "structs.inc.glsl"

layout(local_size_x = 64) in;

struct TransformData {
    vec4 rotation;
    vec3 translation;
    vec3 scale;
};

struct AABB {
    vec3 min;
    vec3 max;
};

// It's fine to put buffer here because I'm not expecting much instancing (if any)
struct MeshData {
    VertexBuffer vertexBuffer;
    IndexBuffer indexBuffer;
    Material material;
    AABB objectAABB;
};

struct RenderData {
    MeshData mesh;
    uint indexCount;
};

layout(set = 0, binding = 0, scalar) readonly buffer RenderDataBuffer {
    RenderData objects[];
} renderData;

layout(set = 0, binding = 1, scalar) readonly buffer VisibleFlags {
    uint flags[];
} visibleFlags;

// TODO: Move to push constants
layout(set = 1, binding = 0, scalar) readonly uniform CullingParameters {
    mat4 viewMatrix;
    vec2 left;
    vec2 right;
    vec2 bottom;
    vec2 top;
    uint objectCount;
} cullingParams;

layout(set = 1, binding = 1, scalar) readonly buffer TransformBuffer {
    TransformData transforms[];
} transformBuffer;

layout(set = 1, binding = 2, scalar) buffer DrawCounter {
    uint count;
} drawCounter;

struct VkDrawIndirectCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

layout(set = 2, binding = 0, scalar) buffer DrawIndirectCommandBuffer {
    VkDrawIndirectCommand commands[];
} drawIndirectCommands;

layout(set = 3, binding = 0, scalar) buffer DrawRecordBuffer {
    DrawRecord drawRecords[];
} drawRecordBuffer;

bool isVisibleFlagSet(uint index) {
    uint dataIndex = index >> 5;
    uint bitIndex = index & 31;
    return (visibleFlags.flags[dataIndex] & (1 << bitIndex)) != 0;
}

mat4 computeTransform(uint index) {
    TransformData t = transformBuffer.transforms[index];

    vec4 q = 1.4142135623730951 * t.rotation; // multiply by sqrt(2) to remove * 2

    float qx2 = q.x * q.x;
    float qy2 = q.y * q.y;
    float qz2 = q.z * q.z;
    float qw2 = q.w * q.w;
    float qxy = q.x * q.y;
    float qxz = q.x * q.z;
    float qxw = q.x * q.w;
    float qyz = q.y * q.z;
    float qyw = q.y * q.w;
    float qzw = q.z * q.w;

    mat4 transform;
    transform[0][0] = 1.0 - qy2 - qz2;
    transform[0][1] = qxy + qzw;
    transform[0][2] = qxz - qyw;
    transform[0][3] = 0.0;
    transform[1][0] = qxy - qzw;
    transform[1][1] = 1.0 - qx2 - qz2;
    transform[1][2] = qyz + qxw;
    transform[1][3] = 0.0;
    transform[2][0] = qxz + qyw;
    transform[2][1] = qyz - qxw;
    transform[2][2] = 1.0 - qx2 - qy2;
    transform[2][3] = 0.0;

    transform[0] *= t.scale.x;
    transform[1] *= t.scale.y;
    transform[2] *= t.scale.z;

    transform[3] = vec4(t.translation, 1.0);

    return transform;
}

bool inFrustum(AABB viewAABB) {
    return true; // TODO: remove

    // Near
    if (viewAABB.max.z < 0.0) {
        return false;
    }

    // Components equal to zero were dropped

    // Left (plane y == 0)
    if (dot(viewAABB.max.xy, cullingParams.left) < 0) {
        return false;
    }

    // Right (plane y == 0)
    if (dot(vec2(viewAABB.min.x, viewAABB.max.z), cullingParams.right) < 0) {
        return false;
    }

    // Bottom (plane x == 0)
    if (dot(viewAABB.max.yz, cullingParams.bottom) < 0) {
        return false;
    }

    // Top (plane x == 0)
    if (dot(viewAABB.min.yz, cullingParams.top) < 0) {
        return false;
    }

    return true;
}

AABB computeViewAABB(mat4 viewSpaceTransform, AABB objectAABB) {
    // Compute world AABB from local AABB, see Graphics Gems - "Transforming Axis-Aligned Bounding Boxes"
    // It's just decomposing the matrix multiplication to avoid doing 8 corner transformations and a lot of min/max ops
    // Not too sure how efficient this is on GPU TBH
    vec3 nmin, nmax;
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 3; ++j) {
            float a = viewSpaceTransform[j][i] * objectAABB.min[j];
            float b = viewSpaceTransform[j][i] * objectAABB.max[j];

            if (a < b) {
                nmin[j] = a;
                nmax[j] = b;
            } else {
                nmin[j] = b;
                nmax[j] = a;
            }
        }
    }
    return AABB(nmin, nmax);
}

void main()
{
    uint index = gl_GlobalInvocationID.x;

    if (index >= cullingParams.objectCount) {
        return;
    }

    if (!isVisibleFlagSet(index)) {
        return;
    }

    RenderData obj = renderData.objects[index];

    mat4 viewSpaceTransform = cullingParams.viewMatrix * computeTransform(index);

    AABB viewAABB = computeViewAABB(viewSpaceTransform, obj.mesh.objectAABB);

    if (inFrustum(viewAABB)) {
        uint drawIndex = atomicAdd(drawCounter.count, 1); // To be reset by CPU before dispatch

        drawIndirectCommands.commands[drawIndex].vertexCount = obj.indexCount;
        drawIndirectCommands.commands[drawIndex].instanceCount = 1;
        drawIndirectCommands.commands[drawIndex].firstVertex = 0;
        drawIndirectCommands.commands[drawIndex].firstInstance = 0;
        drawRecordBuffer.drawRecords[drawIndex].vertexBuffer = obj.mesh.vertexBuffer;
        drawRecordBuffer.drawRecords[drawIndex].indexBuffer = obj.mesh.indexBuffer;
        drawRecordBuffer.drawRecords[drawIndex].material = obj.mesh.material;

        mat4x3 modelViewMatrix;
        modelViewMatrix[0] = vec3(viewSpaceTransform[0]);
        modelViewMatrix[1] = vec3(viewSpaceTransform[1]);
        modelViewMatrix[2] = vec3(viewSpaceTransform[2]);
        modelViewMatrix[3] = vec3(viewSpaceTransform[3]);
        drawRecordBuffer.drawRecords[drawIndex].modelViewMatrix = modelViewMatrix;
    }
}
