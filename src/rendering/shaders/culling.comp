#version 460
#extension GL_EXT_shader_explicit_arithmetic_types : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require

#include "structs.inc.glsl"
#include "culling.inc.glsl"
#include "common.inc.glsl"

layout(local_size_x = 64) in;

layout(set = 0, binding = 0, scalar) readonly buffer RenderDataBuffer {
    RenderData objects[];
} renderData;

layout(set = 0, binding = 1, scalar) readonly buffer VisibleFlags {
    uint flags[];
} visibleFlags;

// Separate buffer for debugging purposes
layout(set = 0, binding = 2, scalar) readonly buffer AABBBuffer {
    AABB aabb[];
} objectAABBs;

layout(set = 1, binding = 0, scalar) readonly buffer TransformBuffer {
    TransformData transforms[];
} transformBuffer;

layout(set = 1, binding = 1, scalar) buffer DrawCounter {
    uint count;
} drawCounter;

struct VkDrawIndirectCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

layout(set = 2, binding = 0, scalar) buffer DrawIndirectCommandBuffer {
    VkDrawIndirectCommand commands[];
} drawIndirectCommands;

layout(set = 3, binding = 0, scalar) buffer DrawRecordBuffer {
    DrawRecord drawRecords[];
} drawRecordBuffer;

layout(push_constant) uniform CullingParametersData
{
    CullingParameters parameters;
} cullingData;

void main()
{
    uint index = gl_GlobalInvocationID.x;

    if (index >= cullingData.parameters.objectCount) {
        return;
    }

    if (!isVisibleFlagSet(visibleFlags.flags, index)) {
        return;
    }

    RenderData obj = renderData.objects[index];

    mat4 viewSpaceTransform = cullingData.parameters.viewMatrix * computeTransform(transformBuffer.transforms[index]);

    AABB viewAABB = transformAABB(viewSpaceTransform, objectAABBs.aabb[index]);

    if (inFrustum(viewAABB, cullingData.parameters)) {
        uint drawIndex = atomicAdd(drawCounter.count, 1); // To be reset by CPU before dispatch

        drawIndirectCommands.commands[drawIndex].vertexCount = obj.indexCount;
        drawIndirectCommands.commands[drawIndex].instanceCount = 1;
        drawIndirectCommands.commands[drawIndex].firstVertex = 0;
        drawIndirectCommands.commands[drawIndex].firstInstance = 0;
        drawRecordBuffer.drawRecords[drawIndex].vertexBuffer = obj.vertexBuffer;
        drawRecordBuffer.drawRecords[drawIndex].indexBuffer = obj.indexBuffer;
        drawRecordBuffer.drawRecords[drawIndex].material = obj.material;

        mat4x3 modelViewMatrix;
        modelViewMatrix[0] = vec3(viewSpaceTransform[0]);
        modelViewMatrix[1] = vec3(viewSpaceTransform[1]);
        modelViewMatrix[2] = vec3(viewSpaceTransform[2]);
        modelViewMatrix[3] = vec3(viewSpaceTransform[3]);
        drawRecordBuffer.drawRecords[drawIndex].modelViewMatrix = modelViewMatrix;
    }
}
